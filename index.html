<!doctype html>
<html lang="en">
  <head>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.3.1/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/speech-commands@0.4.0/dist/speech-commands.min.js"></script>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Artifact Viewer</title>
      <script type="module" crossorigin src="/memory-fys-game/assets/index-8qDLajsS.js"></script>
      <link rel="stylesheet" crossorigin href="/memory-fys-game/assets/index-C099JD6y.css">
    </head>
  <body>
    <!-- Teachable Machine Section -->
    <div style="padding: 20px; border-bottom: 1px solid #ccc; margin-bottom: 20px;">
      <div>Teachable Machine Audio Model</div>
      <button type="button" class="btn btn-primary" onclick="init()">Start</button>
      <div class="form-group"></div>
        <label for="model-url">Teachable machine model URL:</label>
        <input type="text" class="form-control" id="model-url" value="https://teachablemachine.withgoogle.com/models/rnDxAsp_L/" placeholder="Enter model URL">
      </div>
      <div id="label-container"></div>
      <script type="text/javascript">
          async function createModel() {
              const URL = document.getElementById("model-url").value;
              // Add a trailing slash to the URL if it doesn't exist
              if (!URL.endsWith("/")) {
                  URL = URL + "/";
              }
              const checkpointURL = URL + "model.json"; // model topology
              const metadataURL = URL + "metadata.json"; // model metadata
              const recognizer = speechCommands.create(
                  "BROWSER_FFT",
                  undefined,
                  checkpointURL,
                  metadataURL);
              await recognizer.ensureModelLoaded();
              return recognizer;
          }
          async function init() {
              const recognizer = await createModel();
              const classLabels = recognizer.wordLabels();
              const labelContainer = document.getElementById("label-container");
              for (let i = 0; i < classLabels.length; i++) {
                  labelContainer.appendChild(document.createElement("div"));
              }
              
              // Add this at the top with your other variables
              let currentSequence = [];
              const sequenceDisplay = document.createElement('div');
              sequenceDisplay.id = 'sequence-display';
              document.body.appendChild(sequenceDisplay);



              recognizer.listen(result => {
        // Get the most confident prediction
        const scores = result.scores;
        const maxScore = Math.max(...scores);
        const predictedIndex = scores.indexOf(maxScore);
        const predictedLabel = classLabels[predictedIndex];

        // Update raw predictions display
        for (let i = 0; i < classLabels.length; i++) {
            const classPrediction = classLabels[i] + ": " + result.scores[i].toFixed(2);
            labelContainer.childNodes[i].innerHTML = classPrediction;
        }

        // Only process predictions above threshold (e.g., 0.8)
        if (maxScore > 0.8) {
            // Update sequence
            if (currentSequence.length === 0) {
                currentSequence.push(predictedLabel);
            } else {
                // If this is a different label than the last one
                if (predictedLabel !== currentSequence[currentSequence.length - 1]) {
                    if (currentSequence.length === 1) {
                        // Check if it forms a valid sequence
                        if (isValidSequence(currentSequence[0], predictedLabel)) {
                            currentSequence.push(predictedLabel);
                        } else {
                            // Reset to just the new label if not a valid sequence
                            currentSequence = [predictedLabel];
                        }
                    } else {
                        // Reset to just the new label if we already have 2 items
                        currentSequence = [predictedLabel];
                    }
                }
            }

            // Display current sequence
            updateSequenceDisplay();
        }
    }, {
        includeSpectrogram: true,
        probabilityThreshold: 0.75,
        invokeCallbackOnNoiseAndUnknown: true,
        overlapFactor: 0.50
    });
          }


      // Add these helper functions
function isValidSequence(first, second) {
    // Define valid sequences here
    const validSequences = {
        'A': ['2'],  // A can be followed by 2
        // Add more valid first letters and their allowed followers
    };

    return validSequences[first] && validSequences[first].includes(second);
}

function updateSequenceDisplay() {
    sequenceDisplay.innerHTML = `Current Sequence: ${currentSequence.join(' â†’ ')}`;
    
    // Optional: Add some basic styling
    sequenceDisplay.style.padding = '10px';
    sequenceDisplay.style.margin = '10px 0';
    sequenceDisplay.style.fontWeight = 'bold';
    sequenceDisplay.style.backgroundColor = currentSequence.length === 2 ? '#e0ffe0' : '#fff';
}
      </script>
  </div>
    <div id="root"></div>
  </body>
</html>
